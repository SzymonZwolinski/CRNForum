@using Platender.Front.Models
@using Platender.Front.State;
<MudPaper>
    <DataAnnotationsValidator />
    <MudText>Change password:</MudText>
    <MudForm Model="@password">
        <MudCard>
            <MudCardContent>
                <MudTextField @bind-Value="password.OldPassword" For="@(() => password.OldPassword)" Immediate="true"
                    Label="Old Password" InputType="InputType.Password" />
                <MudTextField @bind-Value="password.NewPassword" For="@(() => password.NewPassword)" Immediate="true"
                    Label="New Password" InputType="InputType.Password" />
                <MudTextField @bind-Value="password.NewPassword" For="@(() => password.NewPassword2)" Immediate="true"
                    Label="Repeat new Password" InputType="InputType.Password" />
            </MudCardContent>
            <MudCardActions>
                <MudButton Disabled="@_processing" ButtonType="ButtonType.Submit" Variant="Variant.Filled"
                    Color="Color.Primary" Class="ml-auto">
                    @if (_processing)
                    {
                        <MudProgressCircular Class="ms-n1" Size="Size.Small" Indeterminate="true" />
                        <MudText Class="ms-2">Processing</MudText>
                    }
                    else
                    {
                        <MudText>Submit</MudText>
                    }
                </MudButton>
            </MudCardActions>
        </MudCard>
    </MudForm>
</MudPaper>

@code {
    [Inject]
    private AccountState AccountState { get; set; }
    public UserPasswordChange password = new();

    private bool _processing = false;

    private void OnValidSubmit(EditContext context)
    {
       _processing = true;
       AccountState.IsChangePasswordSent = true;
       Task.Delay(200);
       _processing = false;
       //TODO: ADD FUNCTIONALITY TO CHANGE PASSWORD ON BACKEND First
    } 
}